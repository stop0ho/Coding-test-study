## 파괴되지 않은 건물

### 문제 풀이

- 시간 고려안하면 for문 덕지덕지 붙이면 쉬운 문제다.. 이런 식으로 내면 효율성 0점 나온다ㅎㅎ;
```java
class Solution {
    public int solution(int[][] board, int[][] skill) {
        
        for (int[] s : skill) {
            int type = s[0];
            int r1 = s[1];
            int c1 = s[2];
            int r2 = s[3];
            int c2 = s[4];
            int degree = s[5];
            
            if (type == 1) {
                // 공격
                for (int i = r1; i <= r2; i++) {
                    for (int j = c1; j <= c2; j++) {
                        board[i][j] -= degree;
                    }
                }
            } else {
                // 회복
                for (int i = r1; i <= r2; i++) {
                    for (int j = c1; j <= c2; j++) {
                        board[i][j] += degree;
                    }
                }
            }
        }
        
        int answer = 0;
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] > 0) answer++;
            }
        }
        
        return answer;
    }
}
```
- 문제를 아무리봐도 잘 모르겠어서;;; (자꾸 for문만 쓰고 싶다.) 질문하기 들어가봤는데 엄청 상세하게 접근 과정을 써 주신 분이 계셨다
  - [전현서님의 풀이과정](https://school.programmers.co.kr/questions/25471)을 보면서 풀이 시작!

- [1, 3, 5, 5] 와 같은 1차원 배열이 있을 때 0번 ~ 2번 인덱스까지 피해를 2만큼 준다고 할 때
  - 나였으면 O(n)의 시간복잡도로 순회하면서 빼줬을텐데, 여기서 누적합을 활용하는 것이다!
  1. [0, 0, 0, 0] 으로 초기화된 배열을 새로 만들고, 시작점에 -2(피해를 2주니까), 종료 지점보다 한칸 뒤에 +2(누적합 계산을 위한 반대 부호 값)을 삽입
  2. [-2, 0, 0, 2] 배열이 됐을테니, 여기서부터 누적합 시작!
     - [-2, -2, 0, 2] -> [-2, -2, -2, 2] -> [-2, -2, -2, 0] 으로 누적합 구하기 완료 (우리가 원하는 대로 0번부터 2번 인덱스까지만 피해를 2 주는 그림이 됨.)
  3. [1, 3, 5, 5] 배열과 [-2, -2, -2, 0] 배열을 합하면 우리가 구하고 싶던 [-1, 1, 3, 5] 배열이 완성됨!
- 이러한 누적합을 이용해서 2차원 배열로 확장해서 풀이한다.
  - 4*4 배열에 (0, 0) ~ (2, 2)까지 n만큼 변화를 하는 것으로 예로 들자면
    [n, 0, 0, -n]
    [0, 0, 0, 0]
    [0, 0, 0, 0]
    [-n, 0, 0, n] 형태로 두면 된다! 오른쪽으로, 아래쪽으로 누적합을 구하면 우리가 원하는 형태로
  
    [n, n, n, 0]
    [n, n, n, 0]
    [n, n, n, 0]
    [0, 0, 0, 0] 형태로 변화한다. 여기서 진짜 신기했다;; 나는 이런 생각 정말 못했을 거 같은데...

위의 풀이법을 적용해서 풀이를 하자면
1. 한칸씩 더 큰 배열을 만들어서 (마지막 인덱스까지 변화를 주고 싶은 경우 고려) 0으로 초기화(만들면 어차피 0일테니 초기화 과정은 필요없다.)
2. 내가 변화를 주고 싶은 시작점에 n값을, 종료지점 한칸 뒤를 -n 값을 삽입해서 누적합 구하기
   - (r1, c1) = n / (r1, c2 + 1) = -n / (r2 + 1, c1) = -n / (r2 + 1, c2 + 1) = n 넣기
     - +1 하는 걸 잊지말자...!
     - skill 배열이 끝날때까지 반복하기
3. 완성된 누적합 배열과 board 배열 합쳐서 결과 반환

---
풀이를 안봤으면 내가 이걸 이런 식으로 풀 수 있을까 싶다...
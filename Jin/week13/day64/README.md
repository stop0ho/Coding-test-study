## 📌 문제 탐색하기

### 문제

입력된 바둑판의 상태를 보고 누가 이겼는지 판단하기

- 아직 **승부가 결정되지 않았을 경우 0**, **검은색**이 이겼을 경우 **1**, **흰색**이 이겼을 경우 **2** 출력
    - 승부가 결정됐을 경우, 가장 왼쪽(세로로 놓인 경우에는 가장 위에 있는 것)에 있는 바둑알의 가로줄 번호와 세로줄 번호를 함께 출력
    - 6개 이상 연속된 경우는 승리한 것으로 판단하지 않음

### 조건

19 X 19 바둑판의 상태를 입력으로 주어짐

- 알이 **놓이지 않은 자리 0**, **검은** 바둑알 **1**, **흰** 바둑알 **2**

### 풀이 및 시간 복잡도 고려

두 바둑알 모두 승리할 경우는 입력으로 들어오지 않으므로, 특정 바둑알을 만났을 때 승리 조건을 만족하는지 확인 후 만족한다면 답을 출력하고, 만족하지 않는다면 계속 탐색을 이어나가면 됨

- 끝까지 승리조건을 만족하는 바둑알이 없다면 0을 출력

<img width="735" height="381" alt="image" src="https://github.com/user-attachments/assets/b81b29ba-3ea0-4b6b-b78b-a5b6231ba745" />


바둑판을 탐색한다고 했을 때, 검은색 화살표 방향으로 탐색하기 때문에, 가능한 승리 조건은 오른쪽의 빨간 화살표 모양.

- 기준점 기준 오른쪽 방향
- 기준점 기준 아래쪽 방향
- 기준점 기준 우상향 대각선
- 기준점 기준 우하향 대각선

바둑알이 존재하는 칸에 도착하면, **4방향(우/하/우상/우하) 탐색**을 통해 **같은 색의 바둑알이 5개**가 있는지 확인하기

19 X 19 바둑판을 **완전 탐색**할 때 시간복잡도

→ 각 칸 별로 4방향 탐색을 통해 같은 색의 바둑알이 몇 개 연속되어있는 지 알아야 함(재귀 사용)

최악의 경우 19개 모두 바둑알이 존재할 수 있으므로 최대 19번 재귀

- 바둑판 전체 탐색: 19 X 19
- 각 칸마다 4방향 탐색: 4
- 각 방향 탐색시 최대 19번 재귀 호출: 19

→ O(19 X 19 X 4 X 19) = **O(27,436)**이므로 **1초 이내로 문제 풀이 가능**

4방향 탐색 때 동/남/북동/남동 방향이 필요하므로, **dx/dy 배열을 [동, 남, 북동, 남동] 순으로 작성**

- 동(오른쪽): **y만 증가**
- 남(아래): **x만 증가**
- 북동(우상향): **x 감소, y 증가**
- 남동(우하향): **x 증가, y 증가**

위 변화를 잘 생각해서 dx/dy 배열을 다음과 같이 만들 수 있음

**`dx = [0, 1, -1, 1]`** / **`dy = [1, 0, 1, 1]`**

---

## 📌 코드 설계하기

1. input 입력 받기
2. 승리 조건을 체크하는 함수 생성
3. 승리 조건을 만족하면 바둑알의 색과 가장 왼쪽 위의 바둑알의 좌표를 출력, 끝까지 탐색했지만 승리 조건을 만족하지 못한다면 -1 출력

---

## 📌 시도 회차 수정 사항

### 1회차

- 코드

    ```java
    import java.io.*;
    import java.util.*;
    
    public class Main {
        // 동 남 북동 남동 순서
        static int[] dx = { 0, 1, -1, 1 };
        static int[] dy = { 1, 0, 1, 1 };
        
        public static void main(String[] args) throws Exception {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    
            // 1. input 입력받기
            int[][] board = new int[19][19];
            for (int i = 0; i < 19; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                for (int j = 0; j < 19; j++) {
                    board[i][j] = Integer.parseInt(st.nextToken());
                }
            }
    
            // 2. 탐색
            boolean gameEnd = false;
            for (int x = 0; x < 19; x++) {
                for (int y = 0; y < 19; y++) {
                    if (!gameEnd && board[x][y] != 0) {
                        for (int dir = 0; dir < 4; dir++) {
                            if (!gameEnd && count(x, y, dir, board) == 5) {
                                gameEnd = true;
                                bw.write(board[x][y] + "\n" + (x + 1) + " " + (y + 1));
                                break;
                            }
                        }
                    }
                }
                if (gameEnd) break;
            }
    
            if (!gameEnd) bw.write("0");
            
            bw.flush();
            bw.close();
            br.close();
        }
        
        private static int count(int x, int y, int dir, int[][] board) {
            int nextX = x + dx[dir];
            int nextY = y + dy[dir];
            
            // 바둑판의 범위를 넘어갔을 경우 탐색 종료
            if (nextX < 0 || nextX > 18 || nextY < 0 || nextY > 18) return 1;
            
            // 다음 탐색 위치와 현재 위치의 바둑알의 색이 다르다면 탐색 종료
            if (board[nextX][nextY] != board[x][y]) return 1;
            
            // 진행 방향에 동일한 색의 바둑알이 있는 경우 계속 탐색
            return count(nextX, nextY, dir, board) + 1;
        }
    }
    ```

- 반례

    ```java
    // 입력
    2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
    0 0 0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0 0
    0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 2 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0
    0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 0
    0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
    0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0
    0 0 0 2 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
    0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
    0 0 0 1 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    1 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
    0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
    
    // 출력
    2
    5 15
    
    // 정답
    0
    ```

    - (5, 15) 위치는 육목 위치임에도 불구하고 문제 발생
        - (4, 14) 위치에서 육목이어서 실패했는데, (5, 15) 때는 (4, 14)를 탐색하지 않으므로 오목으로 판단이 되어 문제 발생

      ⇒ **진행방향의 역방향에 현재 바둑알과 동일한 색의 바둑알이 존재한다면 이미 확인한 케이스**이므로 더 이상 진행하지 못하게 하기

## 폰켓몬 문제

### 문제 풀이
- 최대한 중복 없이 폰켓몬을 선택하고 싶은 문제
  - 중복값을 일단 배제

- 1번 입출력 예
  - 총 4마리 폰켓몬 존재, N/2마리를 가지므로 2마리를 가질 수 있음 
  - 중복 제거 [3, 1, 2, 3] -> [1, 2, 3]
  - N/2 값인 2보다 중복 제거한 배열이 더 크므로, 온전하게 다른 종류로 2마리를 가질 수 있음
- 2번 입출력 예
  - 총 6마리 폰켓몬 존재, N/2 = 3. 3마리를 가질 수 있음
  - 중복 제거 [3, 3, 3, 2, 2, 4] -> [2, 3, 4]
  - N/2 값인 3과 배열이 길이가 같음. 온전하게 다른 종류로 3마리를 가질 수 있음
- 3번 입출력 예
  - 총 6마리 폰켓몬 존재, N/2 = 3
  - 중복 제거 [3, 3, 3, 2, 2, 2] -> [2, 3]
  - N/2 값인 3보다 중복 제거한 배열이 더 작음. 다른 종류로는 2마리만 가질 수 있고 나머지 한마리는 무조건 중복 발생

### 결론
- **`(N/2) <= 배열.length`** N/2 가 정답
- **`N/2 > 배열.length`** 배열의 길이가 정답
  => N/2와 배열.length 중 **더 작은 값**이 정답
- SET으로 중복 제거만 한다면 쉽게 풀 수 있는 문제!

### 추가사항
항상.. for문을 애용했던 사람이었기에 이번 기회에는 for문을 사용하지 않고 풀이해보고 싶었다.
Set이 중복 제거가 된다는 것은 알고 있으니, 배열을 Set으로만 바꾼다면! for문 없이 풀 수 있을 거란 생각이 들었다.

```java
Set<Integer> set = new HashSet<Integer>(Arrays.asList(arr)); 
```
간단하게는 위처럼 할 수도 있겠지만...!! 이건 **`Integer[]`** 일때나 가능하다.
문제에서 주어지는 **`int[]`** 배열로는 위 방식처럼 변환이 안된다.

stream을 통해 set으로 변환할 수 있다.
```java
Set<Integer> set = Arrays.stream(arr)
        .boxed()
        .collect(Collectors.toSet());
```
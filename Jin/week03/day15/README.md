## 양과 늑대 문제

### 문제 풀이
- 항상 양의 수가 늑대의 수보다 많게 탐색해야 함
- 최대로 모을 수 있는 양의 수를 구해야 함

=> DFS로 전체 탐색 진행
- 탐색을 하는데, 탐색하는 경로에 따라 다른 정보들을 저장해야 함
  - 양/늑대 수가 달라지니까
  => newVisited 배열을 통해 새로운 배열을 만들어 각각 다른 결과를 가질 수 있게 하기

---
이 문제를 여러 블로그 글들을 보면서 공부하고 풀었는데, 배열 길이 17일 때 시간초과가 나는 방법이더라구요! (중복 존재)
([참고한 블로그 중 하나의 글](https://codingwell.tistory.com/180))

책을 봤을 때 코드가 복잡해보였는데, HashSet 등을 쓰면서 중복을 제거하고 시간 초과가 나지 않는 방법으로 풀이한 것 같습니다.
제가 작성한 코드 자체가 DFS 호출마다 모든 정점 다 돌면서 확인하고... 그런 거니까 시간복잡도가 상당히 높게 잡히는데 책 풀이는 O(N^2) 수준이니 책을 참고해서 추가로 공부를 해야 할 것 같습니당~!~~!
## 📌 문제 탐색하기

### 문제

아래 연산을 이용하여 A를 K로 변경할 때 필요한 최소 연산 횟수 출력

- 정수 A에 1을 더하기
- 정수 A에 2를 곱하기

### 조건

**1 ≤ A < K ≤ 1,000,000**

### 풀이 및 시간 복잡도 고려

[비슷한 문제](https://www.acmicpc.net/problem/1463)를 DP로 풀었던 경험이 있어서.. DP 문제인가? 하는 생각이 들었고, DP로 풀어보기로 했다.

1. **크기가 K + 1인 배열 생성**(1부터 K까지의 최소 연산 횟수를 저장하기 위함)
2. dp[A + 1]부터 dp[K]까지 최소 연산 횟수를 저장

    ```java
    dp[i + 1] = dp[i] + 1;
    dp[i * 2] = dp[i] + 1;
    ```

    - 정수 i에서 연산 수행 후 나올 수 있는 정수는 i + 1 또는 i * 2이므로, 해당 위치에 저장하기
        - 최소 연산 횟수를 저장하는 것이니까 **Math.min(dp[i + 1], dp[i] + 1)** 이런 식으로 저장이 필요할 듯!

          ⇒ **삼항연산자가 필요해보임**

            - **dp[i + 1] 또는 dp[i * 2]의 초기값은 0**인데 (따로 설정하지 않는 이상) 여기서 **min 계산을 하면 당연히 다 0으로 저장됨**

              **dp[i + 1] == 0 ? dp[i] + 1 : Math.min(dp[i + 1], dp[i] + 1)** 와 같이 삼항연산자를 사용해 **초기값 상태면 현재값을 저장**하고, **이미 값이 저장되어있다면 둘 중 최솟값을 저장할 수 있게 하기**


        ⇒ **인덱스 범위를 벗어나는 문제**가 있을 수 있음
        
        - **i + 1 또는 i * 2가 K보다 크다면 아예 연산을 하지 않도록** 하기

배열은 계산의 편의를 위해 K + 1 크기로 만들었지만, **이 공간을 다 써도 512 MB 제한 내로 문제 풀이 가능**

A부터 K까지 반복하며 최소 연산 횟수를 저장하므로 **O(K - A)**의 시간복잡도를 가짐

→ 최악의 경우 A = 1, K = 10^6 이므로 K - A = 10^6 - 1, 대략 **10^6이므로 1초 내로 문제 풀이 가능**

---

## 📌 코드 설계하기

1. input 입력받기
2. 크기가 K + 1인 배열 생성
3. dp 연산
    - 인덱스 범위를 벗어나지 않는 범위 내에서, 최소 횟수 연산하기
4. dp[K] 출력
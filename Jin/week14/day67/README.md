## 📌 문제 탐색하기

### 문제

산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액 찾기

- **1 ≤ 산성 용액의 특성값 ≤ 1,000,000,000**
- **-1,000,000,000 ≤ 알칼리성 용액의 특성값 ≤ -1**

주어진 용액의 특성값이 [-99, -2, -1, 4, 98]인 경우, -99인 용액과 98인 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들 수 있음

- **두 알칼리성 용액 혹은 두 산성 용액만으로** 특성값이 0에 가장 가까운 **혼합 용액을 만드는 경우도 존재**

### 조건

N: 전체 용액의 수 **2 ≤ N ≤ 100,000**

**정렬된 순서로 입력**되는 N개의 용액들의 특성값은 모두 다르고, 산성 용액 혹은 알칼리성 용액으로만 입력이 주어질 수도 있음

각 용액의 합을 구해야 하는 문제인데, **혼합 용액이 가질 수 있는 특성값 또한 -20억부터 20억까지이므로 int로 계산 가능**

### 풀이 및 시간 복잡도 고려

어떻게 이분탐색을 활용해 문제를 풀 수 있을까?

**완전탐색**처럼 접근해보기

1. **전체의 경우 중에서 0에 가장 가까운 경우를 찾아야 함**
2. 그렇다고 **완전탐색으로 계산하면 시간 초과 발생**
    - $nC_2$ → O(n^2) = **10^10이므로 1초 내로 문제 풀이 불가**

   → 모든 경우를 다 탐색하는 것이 아닌, **이분탐색을 사용해 특정 경우에서만 탐색**하기


**경우의 수**는 다음 세 가지가 존재

- **liquid[i] + liquid[j] = 0**
    - **종료 조건**
    - 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우 아무것이나 하나를 출력해도 된다고 했으므로, 이런 경우 만나면 **바로 종료하고 답 출력해도 됨!**
- **liquid[i] + liquid[j] > 0**
    - 정렬된 배열에서 두 가지 값을 뽑았는데 **합이 양수라는 말은, liquid[j] 보다 더 작은 값이 존재하는 j - 1 등의 위치에 있는 값을 꺼내서 합하면 더 0에 가까워질 수 있다는 뜻**

      ⇒ j의 값을 줄이기 = 좌측 탐색 **end = mid - 1**

- **liquid[i] + liquid[j] < 0**
    - 두 수의 **합이 음수라는 말은 j보다 더 뒤에 존재하는 값을 꺼내서 합하면 0에 더 가까워질 수 있다는 뜻**

      ⇒ j의 값 늘리기 = 우측 탐색 **start = mid + 1**


(+) 현재 발견한 용액의 특성값이 0과 가장 가까운 특성값일 수도 있으므로, **매 탐색마다 값을 비교해**(절댓값으로 값을 비교하기) **정답을 꾸준히 업데이트해주기**

- 절댓값으로 값 비교하면, 두 수 중 더 작은 수가 0에 더 가까운 걸 알 수 있음

첫 번째 용액을 선택하는 반복문 N번 반복 + 이분탐색이므로 **O(NlogN)**의 시간복잡도를 가짐

→ 100,000 * log(100,000) = **500,000이므로 1초 내로 문제 풀이 가능**

---

## 📌 코드 설계하기

1. input 입력 받기
2. 이분탐색
    - 완전탐색 하듯이 첫 번째 용액은 고정 + 두 번째 용액은 이분탐색으로 최적의 용액을 찾아내기
        - **liquid[i] + liquid[j] = 0**
        - **liquid[i] + liquid[j] > 0**
        - **liquid[i] + liquid[j] < 0**

          ⇒ 세 가지 조건에 따라 이분탐색의 범위 조절 및 정답 업데이트

3. 정답 출력

---
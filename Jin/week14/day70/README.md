## 📌 문제 탐색하기

### 문제

동근이의 위치와 각 상점 사이의 최단 거리의 합 구하기

- **블록의 경계로만 다닐 수 있음**

입력은 아래 순서대로 들어옴

- 블록의 가로 길이와 세로 길이
- 상점의 개수
    - 상점의 개수만큼 상점의 위치가 들어옴
- 동근이의 위치

### 조건

**1 ≤ 블록의 가로/세로 길이, 상점의 개수  ≤ 100**

### 풀이 및 시간 복잡도 고려

동근이와 상점의 위치를 나타내는 방식이 상당히 독특해서… 문제와 예제를 좀 꼼꼼히 읽어봐야 했다.

입력 예제에 따르면 크기는 0부터 입력값까지. **(M + 1) X (N + 1) 크기의 배열**

상점과 동근이의 위치

- **1 북쪽 / 2 남쪽**
    - 둘째 수는 왼쪽 경계로부터의 거리

  1 x ⇒ (0, x)

  2 x ⇒ (세로 길이, x)

- **3 서쪽 / 4 동쪽**
    - 둘째 수는 위쪽 경계로부터의 거리

  3 x ⇒ (x, 0)

  4 x ⇒ (x, 가로 길이)


**!! 위치를 나타내는 방법이 일반적이지 않음 !!**

- 위에서 생각한 거대로, 상점의 위치 저장할 때 미리 **배열의 위치에 맞게 조정해서 저장**

**최단거리**이므로 **BFS**로 접근

- 이동이 가능한 위치는 가장자리밖에 없음 → 메서드를 만들어 가장자리인 경우에만 이동할 수 있게 하기
    - **배열 인덱스 범위를 벗어나지 않으면서, 가장자리여야 함**
- 방문 배열과 최소 거리 배열 생성
    - 최소 거리 배열로만 방문 여부와 거리 모두 체크하기
        - 방문 여부를 체크해야 하므로, 최초 위치를 -1 또는 1과 같이 다른 값으로 저장해놔야 시계 또는 반시계 방향으로 한바퀴 돌았을 때 최초 위치를 방문하지 않음

          ⇒ 이렇게 하면 배열을 하나만 써서 편하긴 하겠지만.. **탐색 후 결과 값에 +1 또는 -1을 해줘야 해서 깔끔해보이지 않음..**


    ⇒ 메모리가 부족하지 않으므로 **방문 배열과 최소 거리 배열을 따로 관리!**


BFS의 시간복잡도는 O(V + E)

→ **정점의 수**는 **가장자리만 방문**하므로, **2 X (N + M)개**

→ **간선의 수**는 **최초 시작점을 제외하고는 한 방향으로만 이동**하므로(방문한 곳은 다시 방문하지 않기 때문에 시계면 쭉 시계로, 반시계면 쭉 반시계로 이동함) **정점의 수와 거의 동일**

BFS는 상점의 개수만큼 반복하므로, O(상점의 수 * (V + E)) = **O(상점의 수 * 2V)**의 시간복잡도를 가짐

→ 100 * 2 * (2 * (100 + 100)) = 100 * 4 * 200 = **80,000이므로 1초 내로 문제 풀이 가능**

---

## 📌 코드 설계하기

1. input 입력 받기
    - 상점과 동근이의 위치를 저장할 배열 생성
2. 각 상점 위치마다 BFS 진행 후, 최소 거리를 합산
    - BFS마다 방문배열 초기화 후 탐색 진행
3. 정답 출력

---
## 📌 문제 탐색하기

### 문제

정수 n을 1, 2, 3의 합으로 나타내는 방법의 수 구하기

### 조건

T: 테스트 케이스의 개수

n: 1, 2, 3의 합으로 나타낼 정수 **1 ≤ n < 11**

### 풀이 및 시간 복잡도 고려

동적 계획법(Dynamic Programming) 푸는 방법

- 큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복해서 등장해야 함

→ 작은 문제를 풀면서 발생하는 규칙을 찾고, 이 규칙을 바탕으로 점화식을 추론

**정수 4** → 정수 3을 만드는 가짓수 + 정수 2를 만드는 가짓수 + 정수 1을 만드는 가짓수 = 4 + 2 + 1 = **7**

**정수 5** → 정수 4를 만드는 가짓수 + 정수 3을 만드는 가짓수 + 정수 2를 만드는 가짓수 = 7 + 4 + 2 = **13**

**정수 6** → 13 + 7 + 4 = 24

**정수 7** → 24 + 13 + 7 = **44**

**정수 8** → 44 + 24 + 13 = 81

**정수 9** → 81 + 44 + 24 = 149

**정수 10** → 149 + 81 + 44 = **274**

위 결과를 바탕으로 점화식은 아래와 같이 작성할 수 있다.

$$
dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] (i ≥ 4)
$$

- 문제를 봤을 때 바로 떠오르진 않았지만, 직접 5까지 써보고 점화식을 도출해본 다음에 풀이를 다음과 같이 얻을 수 있었음 ([질문 게시판](https://www.acmicpc.net/board/view/153465)에 자세히 써져있는 답변도 있어서 첨부해봅니다.)
    - 정수 7을 1, 2, 3의 합으로만 나타낸다고 했을 때 다음과 같은 형태가 발생함
        - (1, 2, 3의 합으로 만들어낸 6) + 1
        - (1, 2, 3의 합으로 만들어낸 5) + 2
        - (1, 2, 3의 합으로 만들어낸 4) + 3

      ⇒  위 경우의 합으로 정수 7을 만들어낼 수 있기 때문에 점화식을 위와 같이 쓸 수 있음


메모이제이션을 사용하지 않을 때 시간복잡도는 **O(T * n)**

- n < 11인 자연수이고 단순 덧셈 계산만 반복하기 때문에 각 테스트 케이스마다 반복 실행해도 시간 초과는 발생하지 않을 것으로 예상됨.

→ 그러나, 메모이제이션을 사용해 처음부터 **정수 10까지의 가짓수를 모두 구해둘 경우** **O(n)의 시간복잡도**를 가지고(이 문제에서는 최대 10번), 각 케이스마다 배열에 저장된 값만 출력하면 되니 **O(1) * T = O(T)의 시간복잡도**를 가짐

⇒ 따라서, 총 시간복잡도는 **O(n + T)**인데, n이 최대 10이라는 작은 숫자이므로 **O(n + T) ≈ O(T) 정도로 생각**할 수 있음

---

## 📌 코드 설계하기

1. memo 배열에 1, 2, 3의 합으로 나타내는 방법의 수를 저장
    - n ≤ 10인 정수
2. 테스트 케이스 입력 받기
3. memo 배열에 저장된 값을 출력

---

## 📌 정답 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    static int MAX_VALUE = 11;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        // 1. memo 배열에 가짓수 저장
        int[] memo = new int[MAX_VALUE];
        memo[1] = 1;
        memo[2] = 2;
        memo[3] = 4;
        for (int i = 4; i < MAX_VALUE; i++) {
            memo[i] = memo[i - 1] + memo[i - 2] + memo[i - 3];
        }
        
        // 2. 테스트 케이스 입력받기
        int T = Integer.parseInt(br.readLine());
        for (int i = 0; i < T; i++) {
            int n = Integer.parseInt(br.readLine());
            
            // 3. memo 배열에 저장된 값 출력
            bw.write(memo[n] + "\n");
        }
        
        bw.flush();
        bw.close();
        br.close();
    }
}
```

[동일한 문제이지만 n의 범위가 달라져서 조금은 더 생각했어야 하는 문제](https://www.acmicpc.net/problem/15988)

- 물론 메모이제이션을 이미 활용해서 풀이했기 때문에, 범위만 조금 더 신경 쓴다면 쉽게 풀 수 있어 1초컷했다..ㅎㅎ